// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgHeaders.proto

#ifndef PROTOBUF_MsgHeaders_2eproto__INCLUDED
#define PROTOBUF_MsgHeaders_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace vrm_protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgHeaders_2eproto();
void protobuf_AssignDesc_MsgHeaders_2eproto();
void protobuf_ShutdownFile_MsgHeaders_2eproto();

class CmdHeader;
class ImgGroupHeader;
class CamCalib;
class VrmMatrix;

enum VrmCmd {
  CMD_UNKNOWN = 0,
  CMD_SET_PARAMETERS = 1,
  CMD_TRIGGER_CAM = 2,
  CMD_SEND_CALIB = 3,
  CMD_UPDATE_CALIB = 4
};
bool VrmCmd_IsValid(int value);
const VrmCmd VrmCmd_MIN = CMD_UNKNOWN;
const VrmCmd VrmCmd_MAX = CMD_UPDATE_CALIB;
const int VrmCmd_ARRAYSIZE = VrmCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* VrmCmd_descriptor();
inline const ::std::string& VrmCmd_Name(VrmCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    VrmCmd_descriptor(), value);
}
inline bool VrmCmd_Parse(
    const ::std::string& name, VrmCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VrmCmd>(
    VrmCmd_descriptor(), name, value);
}
enum CamMode {
  MODE_UNKNOWN = 0,
  MODE_STREAMING = 1,
  MODE_STRIPE_PATTERN = 2,
  MODE_RANDOM_DOT_PATTERN = 3,
  MODE_HDR = 4
};
bool CamMode_IsValid(int value);
const CamMode CamMode_MIN = MODE_UNKNOWN;
const CamMode CamMode_MAX = MODE_HDR;
const int CamMode_ARRAYSIZE = CamMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CamMode_descriptor();
inline const ::std::string& CamMode_Name(CamMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CamMode_descriptor(), value);
}
inline bool CamMode_Parse(
    const ::std::string& name, CamMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CamMode>(
    CamMode_descriptor(), name, value);
}
enum TrigMode {
  TRIG_UNKNOWN = 0,
  TRIG_INTERNAL = 1,
  TRIG_EXTERNAL = 2,
  TRIG_SOFTWARE = 3
};
bool TrigMode_IsValid(int value);
const TrigMode TrigMode_MIN = TRIG_UNKNOWN;
const TrigMode TrigMode_MAX = TRIG_SOFTWARE;
const int TrigMode_ARRAYSIZE = TrigMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrigMode_descriptor();
inline const ::std::string& TrigMode_Name(TrigMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrigMode_descriptor(), value);
}
inline bool TrigMode_Parse(
    const ::std::string& name, TrigMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrigMode>(
    TrigMode_descriptor(), name, value);
}
enum ActiveCams {
  CAMS_NONE = 0,
  CAMS_LEFT_CENTER_RIGHT = 1,
  CAMS_LEFT_RIGHT = 2,
  CAMS_LEFT_CENTER = 3,
  CAMS_CENTER_RIGHT = 4
};
bool ActiveCams_IsValid(int value);
const ActiveCams ActiveCams_MIN = CAMS_NONE;
const ActiveCams ActiveCams_MAX = CAMS_CENTER_RIGHT;
const int ActiveCams_ARRAYSIZE = ActiveCams_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActiveCams_descriptor();
inline const ::std::string& ActiveCams_Name(ActiveCams value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActiveCams_descriptor(), value);
}
inline bool ActiveCams_Parse(
    const ::std::string& name, ActiveCams* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActiveCams>(
    ActiveCams_descriptor(), name, value);
}
enum PatternType {
  PATTERN_CONV_GC = 0,
  PATTERN_LARGE_GAP_GC = 1
};
bool PatternType_IsValid(int value);
const PatternType PatternType_MIN = PATTERN_CONV_GC;
const PatternType PatternType_MAX = PATTERN_LARGE_GAP_GC;
const int PatternType_ARRAYSIZE = PatternType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PatternType_descriptor();
inline const ::std::string& PatternType_Name(PatternType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PatternType_descriptor(), value);
}
inline bool PatternType_Parse(
    const ::std::string& name, PatternType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PatternType>(
    PatternType_descriptor(), name, value);
}
// ===================================================================

class CmdHeader : public ::google::protobuf::Message {
 public:
  CmdHeader();
  virtual ~CmdHeader();

  CmdHeader(const CmdHeader& from);

  inline CmdHeader& operator=(const CmdHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdHeader& default_instance();

  void Swap(CmdHeader* other);

  // implements Message ----------------------------------------------

  CmdHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdHeader& from);
  void MergeFrom(const CmdHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // optional double timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional .vrm_protocol.VrmCmd command = 3;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 3;
  inline ::vrm_protocol::VrmCmd command() const;
  inline void set_command(::vrm_protocol::VrmCmd value);

  // optional .vrm_protocol.CamMode cam_mode = 4;
  inline bool has_cam_mode() const;
  inline void clear_cam_mode();
  static const int kCamModeFieldNumber = 4;
  inline ::vrm_protocol::CamMode cam_mode() const;
  inline void set_cam_mode(::vrm_protocol::CamMode value);

  // optional .vrm_protocol.TrigMode trig_mode = 5;
  inline bool has_trig_mode() const;
  inline void clear_trig_mode();
  static const int kTrigModeFieldNumber = 5;
  inline ::vrm_protocol::TrigMode trig_mode() const;
  inline void set_trig_mode(::vrm_protocol::TrigMode value);

  // optional double frame_rate = 6;
  inline bool has_frame_rate() const;
  inline void clear_frame_rate();
  static const int kFrameRateFieldNumber = 6;
  inline double frame_rate() const;
  inline void set_frame_rate(double value);

  // optional bool pattern_partial_view = 7;
  inline bool has_pattern_partial_view() const;
  inline void clear_pattern_partial_view();
  static const int kPatternPartialViewFieldNumber = 7;
  inline bool pattern_partial_view() const;
  inline void set_pattern_partial_view(bool value);

  // optional uint32 pattern_resolution = 8;
  inline bool has_pattern_resolution() const;
  inline void clear_pattern_resolution();
  static const int kPatternResolutionFieldNumber = 8;
  inline ::google::protobuf::uint32 pattern_resolution() const;
  inline void set_pattern_resolution(::google::protobuf::uint32 value);

  // optional .vrm_protocol.PatternType pattern_type = 9;
  inline bool has_pattern_type() const;
  inline void clear_pattern_type();
  static const int kPatternTypeFieldNumber = 9;
  inline ::vrm_protocol::PatternType pattern_type() const;
  inline void set_pattern_type(::vrm_protocol::PatternType value);

  // repeated double exposure_grey = 10;
  inline int exposure_grey_size() const;
  inline void clear_exposure_grey();
  static const int kExposureGreyFieldNumber = 10;
  inline double exposure_grey(int index) const;
  inline void set_exposure_grey(int index, double value);
  inline void add_exposure_grey(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      exposure_grey() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_exposure_grey();

  // repeated double exposure_color = 11;
  inline int exposure_color_size() const;
  inline void clear_exposure_color();
  static const int kExposureColorFieldNumber = 11;
  inline double exposure_color(int index) const;
  inline void set_exposure_color(int index, double value);
  inline void add_exposure_color(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      exposure_color() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_exposure_color();

  // repeated double gain = 12;
  inline int gain_size() const;
  inline void clear_gain();
  static const int kGainFieldNumber = 12;
  inline double gain(int index) const;
  inline void set_gain(int index, double value);
  inline void add_gain(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      gain() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_gain();

  // optional .vrm_protocol.CamCalib left_cam = 13;
  inline bool has_left_cam() const;
  inline void clear_left_cam();
  static const int kLeftCamFieldNumber = 13;
  inline const ::vrm_protocol::CamCalib& left_cam() const;
  inline ::vrm_protocol::CamCalib* mutable_left_cam();
  inline ::vrm_protocol::CamCalib* release_left_cam();
  inline void set_allocated_left_cam(::vrm_protocol::CamCalib* left_cam);

  // optional .vrm_protocol.CamCalib right_cam = 14;
  inline bool has_right_cam() const;
  inline void clear_right_cam();
  static const int kRightCamFieldNumber = 14;
  inline const ::vrm_protocol::CamCalib& right_cam() const;
  inline ::vrm_protocol::CamCalib* mutable_right_cam();
  inline ::vrm_protocol::CamCalib* release_right_cam();
  inline void set_allocated_right_cam(::vrm_protocol::CamCalib* right_cam);

  // optional .vrm_protocol.CamCalib color_cam = 15;
  inline bool has_color_cam() const;
  inline void clear_color_cam();
  static const int kColorCamFieldNumber = 15;
  inline const ::vrm_protocol::CamCalib& color_cam() const;
  inline ::vrm_protocol::CamCalib* mutable_color_cam();
  inline ::vrm_protocol::CamCalib* release_color_cam();
  inline void set_allocated_color_cam(::vrm_protocol::CamCalib* color_cam);

  // optional .vrm_protocol.ActiveCams active_cams = 16;
  inline bool has_active_cams() const;
  inline void clear_active_cams();
  static const int kActiveCamsFieldNumber = 16;
  inline ::vrm_protocol::ActiveCams active_cams() const;
  inline void set_active_cams(::vrm_protocol::ActiveCams value);

  // optional bool simple_occlusion = 17;
  inline bool has_simple_occlusion() const;
  inline void clear_simple_occlusion();
  static const int kSimpleOcclusionFieldNumber = 17;
  inline bool simple_occlusion() const;
  inline void set_simple_occlusion(bool value);

  // optional bool point_colors = 18;
  inline bool has_point_colors() const;
  inline void clear_point_colors();
  static const int kPointColorsFieldNumber = 18;
  inline bool point_colors() const;
  inline void set_point_colors(bool value);

  // @@protoc_insertion_point(class_scope:vrm_protocol.CmdHeader)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_cam_mode();
  inline void clear_has_cam_mode();
  inline void set_has_trig_mode();
  inline void clear_has_trig_mode();
  inline void set_has_frame_rate();
  inline void clear_has_frame_rate();
  inline void set_has_pattern_partial_view();
  inline void clear_has_pattern_partial_view();
  inline void set_has_pattern_resolution();
  inline void clear_has_pattern_resolution();
  inline void set_has_pattern_type();
  inline void clear_has_pattern_type();
  inline void set_has_left_cam();
  inline void clear_has_left_cam();
  inline void set_has_right_cam();
  inline void clear_has_right_cam();
  inline void set_has_color_cam();
  inline void clear_has_color_cam();
  inline void set_has_active_cams();
  inline void clear_has_active_cams();
  inline void set_has_simple_occlusion();
  inline void clear_has_simple_occlusion();
  inline void set_has_point_colors();
  inline void clear_has_point_colors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  ::google::protobuf::uint32 msg_id_;
  int command_;
  int cam_mode_;
  int trig_mode_;
  double frame_rate_;
  ::google::protobuf::uint32 pattern_resolution_;
  int pattern_type_;
  ::google::protobuf::RepeatedField< double > exposure_grey_;
  ::google::protobuf::RepeatedField< double > exposure_color_;
  ::google::protobuf::RepeatedField< double > gain_;
  ::vrm_protocol::CamCalib* left_cam_;
  ::vrm_protocol::CamCalib* right_cam_;
  bool pattern_partial_view_;
  bool simple_occlusion_;
  bool point_colors_;
  int active_cams_;
  ::vrm_protocol::CamCalib* color_cam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_MsgHeaders_2eproto();
  friend void protobuf_AssignDesc_MsgHeaders_2eproto();
  friend void protobuf_ShutdownFile_MsgHeaders_2eproto();

  void InitAsDefaultInstance();
  static CmdHeader* default_instance_;
};
// -------------------------------------------------------------------

class ImgGroupHeader : public ::google::protobuf::Message {
 public:
  ImgGroupHeader();
  virtual ~ImgGroupHeader();

  ImgGroupHeader(const ImgGroupHeader& from);

  inline ImgGroupHeader& operator=(const ImgGroupHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImgGroupHeader& default_instance();

  void Swap(ImgGroupHeader* other);

  // implements Message ----------------------------------------------

  ImgGroupHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImgGroupHeader& from);
  void MergeFrom(const ImgGroupHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // optional double timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional .vrm_protocol.CamMode cam_mode = 3;
  inline bool has_cam_mode() const;
  inline void clear_cam_mode();
  static const int kCamModeFieldNumber = 3;
  inline ::vrm_protocol::CamMode cam_mode() const;
  inline void set_cam_mode(::vrm_protocol::CamMode value);

  // optional uint32 sequence_id = 4;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 4;
  inline ::google::protobuf::uint32 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint32 value);

  // optional uint32 image_id = 5;
  inline bool has_image_id() const;
  inline void clear_image_id();
  static const int kImageIdFieldNumber = 5;
  inline ::google::protobuf::uint32 image_id() const;
  inline void set_image_id(::google::protobuf::uint32 value);

  // optional uint32 num_images = 6;
  inline bool has_num_images() const;
  inline void clear_num_images();
  static const int kNumImagesFieldNumber = 6;
  inline ::google::protobuf::uint32 num_images() const;
  inline void set_num_images(::google::protobuf::uint32 value);

  // optional uint32 exposure_id = 7;
  inline bool has_exposure_id() const;
  inline void clear_exposure_id();
  static const int kExposureIdFieldNumber = 7;
  inline ::google::protobuf::uint32 exposure_id() const;
  inline void set_exposure_id(::google::protobuf::uint32 value);

  // optional uint32 num_exposures = 8;
  inline bool has_num_exposures() const;
  inline void clear_num_exposures();
  static const int kNumExposuresFieldNumber = 8;
  inline ::google::protobuf::uint32 num_exposures() const;
  inline void set_num_exposures(::google::protobuf::uint32 value);

  // optional bool is_full_view = 9;
  inline bool has_is_full_view() const;
  inline void clear_is_full_view();
  static const int kIsFullViewFieldNumber = 9;
  inline bool is_full_view() const;
  inline void set_is_full_view(bool value);

  // optional bool has_left_img = 10;
  inline bool has_has_left_img() const;
  inline void clear_has_left_img();
  static const int kHasLeftImgFieldNumber = 10;
  inline bool has_left_img() const;
  inline void set_has_left_img(bool value);

  // optional bool has_right_img = 11;
  inline bool has_has_right_img() const;
  inline void clear_has_right_img();
  static const int kHasRightImgFieldNumber = 11;
  inline bool has_right_img() const;
  inline void set_has_right_img(bool value);

  // optional bool has_color_img = 12;
  inline bool has_has_color_img() const;
  inline void clear_has_color_img();
  static const int kHasColorImgFieldNumber = 12;
  inline bool has_color_img() const;
  inline void set_has_color_img(bool value);

  // optional bool has_ambient_img = 13;
  inline bool has_has_ambient_img() const;
  inline void clear_has_ambient_img();
  static const int kHasAmbientImgFieldNumber = 13;
  inline bool has_ambient_img() const;
  inline void set_has_ambient_img(bool value);

  // optional bool has_point_color_img = 14;
  inline bool has_has_point_color_img() const;
  inline void clear_has_point_color_img();
  static const int kHasPointColorImgFieldNumber = 14;
  inline bool has_point_color_img() const;
  inline void set_has_point_color_img(bool value);

  // optional .vrm_protocol.PatternType pattern_type = 15;
  inline bool has_pattern_type() const;
  inline void clear_pattern_type();
  static const int kPatternTypeFieldNumber = 15;
  inline ::vrm_protocol::PatternType pattern_type() const;
  inline void set_pattern_type(::vrm_protocol::PatternType value);

  // @@protoc_insertion_point(class_scope:vrm_protocol.ImgGroupHeader)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_cam_mode();
  inline void clear_has_cam_mode();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_image_id();
  inline void clear_has_image_id();
  inline void set_has_num_images();
  inline void clear_has_num_images();
  inline void set_has_exposure_id();
  inline void clear_has_exposure_id();
  inline void set_has_num_exposures();
  inline void clear_has_num_exposures();
  inline void set_has_is_full_view();
  inline void clear_has_is_full_view();
  inline void set_has_has_left_img();
  inline void clear_has_has_left_img();
  inline void set_has_has_right_img();
  inline void clear_has_has_right_img();
  inline void set_has_has_color_img();
  inline void clear_has_has_color_img();
  inline void set_has_has_ambient_img();
  inline void clear_has_has_ambient_img();
  inline void set_has_has_point_color_img();
  inline void clear_has_has_point_color_img();
  inline void set_has_pattern_type();
  inline void clear_has_pattern_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  ::google::protobuf::uint32 msg_id_;
  int cam_mode_;
  ::google::protobuf::uint32 sequence_id_;
  ::google::protobuf::uint32 image_id_;
  ::google::protobuf::uint32 num_images_;
  ::google::protobuf::uint32 exposure_id_;
  ::google::protobuf::uint32 num_exposures_;
  bool is_full_view_;
  bool has_left_img_;
  bool has_right_img_;
  bool has_color_img_;
  bool has_ambient_img_;
  bool has_point_color_img_;
  int pattern_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_MsgHeaders_2eproto();
  friend void protobuf_AssignDesc_MsgHeaders_2eproto();
  friend void protobuf_ShutdownFile_MsgHeaders_2eproto();

  void InitAsDefaultInstance();
  static ImgGroupHeader* default_instance_;
};
// -------------------------------------------------------------------

class CamCalib : public ::google::protobuf::Message {
 public:
  CamCalib();
  virtual ~CamCalib();

  CamCalib(const CamCalib& from);

  inline CamCalib& operator=(const CamCalib& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CamCalib& default_instance();

  void Swap(CamCalib* other);

  // implements Message ----------------------------------------------

  CamCalib* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CamCalib& from);
  void MergeFrom(const CamCalib& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vrm_protocol.VrmMatrix cam_mat = 1;
  inline bool has_cam_mat() const;
  inline void clear_cam_mat();
  static const int kCamMatFieldNumber = 1;
  inline const ::vrm_protocol::VrmMatrix& cam_mat() const;
  inline ::vrm_protocol::VrmMatrix* mutable_cam_mat();
  inline ::vrm_protocol::VrmMatrix* release_cam_mat();
  inline void set_allocated_cam_mat(::vrm_protocol::VrmMatrix* cam_mat);

  // optional .vrm_protocol.VrmMatrix dist_coef = 2;
  inline bool has_dist_coef() const;
  inline void clear_dist_coef();
  static const int kDistCoefFieldNumber = 2;
  inline const ::vrm_protocol::VrmMatrix& dist_coef() const;
  inline ::vrm_protocol::VrmMatrix* mutable_dist_coef();
  inline ::vrm_protocol::VrmMatrix* release_dist_coef();
  inline void set_allocated_dist_coef(::vrm_protocol::VrmMatrix* dist_coef);

  // optional .vrm_protocol.VrmMatrix rect_mat = 3;
  inline bool has_rect_mat() const;
  inline void clear_rect_mat();
  static const int kRectMatFieldNumber = 3;
  inline const ::vrm_protocol::VrmMatrix& rect_mat() const;
  inline ::vrm_protocol::VrmMatrix* mutable_rect_mat();
  inline ::vrm_protocol::VrmMatrix* release_rect_mat();
  inline void set_allocated_rect_mat(::vrm_protocol::VrmMatrix* rect_mat);

  // optional .vrm_protocol.VrmMatrix proj_mat = 4;
  inline bool has_proj_mat() const;
  inline void clear_proj_mat();
  static const int kProjMatFieldNumber = 4;
  inline const ::vrm_protocol::VrmMatrix& proj_mat() const;
  inline ::vrm_protocol::VrmMatrix* mutable_proj_mat();
  inline ::vrm_protocol::VrmMatrix* release_proj_mat();
  inline void set_allocated_proj_mat(::vrm_protocol::VrmMatrix* proj_mat);

  // @@protoc_insertion_point(class_scope:vrm_protocol.CamCalib)
 private:
  inline void set_has_cam_mat();
  inline void clear_has_cam_mat();
  inline void set_has_dist_coef();
  inline void clear_has_dist_coef();
  inline void set_has_rect_mat();
  inline void clear_has_rect_mat();
  inline void set_has_proj_mat();
  inline void clear_has_proj_mat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::vrm_protocol::VrmMatrix* cam_mat_;
  ::vrm_protocol::VrmMatrix* dist_coef_;
  ::vrm_protocol::VrmMatrix* rect_mat_;
  ::vrm_protocol::VrmMatrix* proj_mat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgHeaders_2eproto();
  friend void protobuf_AssignDesc_MsgHeaders_2eproto();
  friend void protobuf_ShutdownFile_MsgHeaders_2eproto();

  void InitAsDefaultInstance();
  static CamCalib* default_instance_;
};
// -------------------------------------------------------------------

class VrmMatrix : public ::google::protobuf::Message {
 public:
  VrmMatrix();
  virtual ~VrmMatrix();

  VrmMatrix(const VrmMatrix& from);

  inline VrmMatrix& operator=(const VrmMatrix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VrmMatrix& default_instance();

  void Swap(VrmMatrix* other);

  // implements Message ----------------------------------------------

  VrmMatrix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VrmMatrix& from);
  void MergeFrom(const VrmMatrix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rows = 1;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 1;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);

  // required uint32 cols = 2;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 2;
  inline ::google::protobuf::uint32 cols() const;
  inline void set_cols(::google::protobuf::uint32 value);

  // repeated double data = 3 [packed = true];
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline double data(int index) const;
  inline void set_data(int index, double value);
  inline void add_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:vrm_protocol.VrmMatrix)
 private:
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_cols();
  inline void clear_has_cols();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 cols_;
  ::google::protobuf::RepeatedField< double > data_;
  mutable int _data_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgHeaders_2eproto();
  friend void protobuf_AssignDesc_MsgHeaders_2eproto();
  friend void protobuf_ShutdownFile_MsgHeaders_2eproto();

  void InitAsDefaultInstance();
  static VrmMatrix* default_instance_;
};
// ===================================================================


// ===================================================================

// CmdHeader

// optional uint32 msg_id = 1;
inline bool CmdHeader::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdHeader::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdHeader::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdHeader::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 CmdHeader::msg_id() const {
  return msg_id_;
}
inline void CmdHeader::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional double timestamp = 2;
inline bool CmdHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdHeader::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double CmdHeader::timestamp() const {
  return timestamp_;
}
inline void CmdHeader::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .vrm_protocol.VrmCmd command = 3;
inline bool CmdHeader::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CmdHeader::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CmdHeader::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CmdHeader::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::vrm_protocol::VrmCmd CmdHeader::command() const {
  return static_cast< ::vrm_protocol::VrmCmd >(command_);
}
inline void CmdHeader::set_command(::vrm_protocol::VrmCmd value) {
  assert(::vrm_protocol::VrmCmd_IsValid(value));
  set_has_command();
  command_ = value;
}

// optional .vrm_protocol.CamMode cam_mode = 4;
inline bool CmdHeader::has_cam_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CmdHeader::set_has_cam_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CmdHeader::clear_has_cam_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CmdHeader::clear_cam_mode() {
  cam_mode_ = 0;
  clear_has_cam_mode();
}
inline ::vrm_protocol::CamMode CmdHeader::cam_mode() const {
  return static_cast< ::vrm_protocol::CamMode >(cam_mode_);
}
inline void CmdHeader::set_cam_mode(::vrm_protocol::CamMode value) {
  assert(::vrm_protocol::CamMode_IsValid(value));
  set_has_cam_mode();
  cam_mode_ = value;
}

// optional .vrm_protocol.TrigMode trig_mode = 5;
inline bool CmdHeader::has_trig_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CmdHeader::set_has_trig_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CmdHeader::clear_has_trig_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CmdHeader::clear_trig_mode() {
  trig_mode_ = 0;
  clear_has_trig_mode();
}
inline ::vrm_protocol::TrigMode CmdHeader::trig_mode() const {
  return static_cast< ::vrm_protocol::TrigMode >(trig_mode_);
}
inline void CmdHeader::set_trig_mode(::vrm_protocol::TrigMode value) {
  assert(::vrm_protocol::TrigMode_IsValid(value));
  set_has_trig_mode();
  trig_mode_ = value;
}

// optional double frame_rate = 6;
inline bool CmdHeader::has_frame_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CmdHeader::set_has_frame_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CmdHeader::clear_has_frame_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CmdHeader::clear_frame_rate() {
  frame_rate_ = 0;
  clear_has_frame_rate();
}
inline double CmdHeader::frame_rate() const {
  return frame_rate_;
}
inline void CmdHeader::set_frame_rate(double value) {
  set_has_frame_rate();
  frame_rate_ = value;
}

// optional bool pattern_partial_view = 7;
inline bool CmdHeader::has_pattern_partial_view() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CmdHeader::set_has_pattern_partial_view() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CmdHeader::clear_has_pattern_partial_view() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CmdHeader::clear_pattern_partial_view() {
  pattern_partial_view_ = false;
  clear_has_pattern_partial_view();
}
inline bool CmdHeader::pattern_partial_view() const {
  return pattern_partial_view_;
}
inline void CmdHeader::set_pattern_partial_view(bool value) {
  set_has_pattern_partial_view();
  pattern_partial_view_ = value;
}

// optional uint32 pattern_resolution = 8;
inline bool CmdHeader::has_pattern_resolution() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CmdHeader::set_has_pattern_resolution() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CmdHeader::clear_has_pattern_resolution() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CmdHeader::clear_pattern_resolution() {
  pattern_resolution_ = 0u;
  clear_has_pattern_resolution();
}
inline ::google::protobuf::uint32 CmdHeader::pattern_resolution() const {
  return pattern_resolution_;
}
inline void CmdHeader::set_pattern_resolution(::google::protobuf::uint32 value) {
  set_has_pattern_resolution();
  pattern_resolution_ = value;
}

// optional .vrm_protocol.PatternType pattern_type = 9;
inline bool CmdHeader::has_pattern_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CmdHeader::set_has_pattern_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CmdHeader::clear_has_pattern_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CmdHeader::clear_pattern_type() {
  pattern_type_ = 0;
  clear_has_pattern_type();
}
inline ::vrm_protocol::PatternType CmdHeader::pattern_type() const {
  return static_cast< ::vrm_protocol::PatternType >(pattern_type_);
}
inline void CmdHeader::set_pattern_type(::vrm_protocol::PatternType value) {
  assert(::vrm_protocol::PatternType_IsValid(value));
  set_has_pattern_type();
  pattern_type_ = value;
}

// repeated double exposure_grey = 10;
inline int CmdHeader::exposure_grey_size() const {
  return exposure_grey_.size();
}
inline void CmdHeader::clear_exposure_grey() {
  exposure_grey_.Clear();
}
inline double CmdHeader::exposure_grey(int index) const {
  return exposure_grey_.Get(index);
}
inline void CmdHeader::set_exposure_grey(int index, double value) {
  exposure_grey_.Set(index, value);
}
inline void CmdHeader::add_exposure_grey(double value) {
  exposure_grey_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CmdHeader::exposure_grey() const {
  return exposure_grey_;
}
inline ::google::protobuf::RepeatedField< double >*
CmdHeader::mutable_exposure_grey() {
  return &exposure_grey_;
}

// repeated double exposure_color = 11;
inline int CmdHeader::exposure_color_size() const {
  return exposure_color_.size();
}
inline void CmdHeader::clear_exposure_color() {
  exposure_color_.Clear();
}
inline double CmdHeader::exposure_color(int index) const {
  return exposure_color_.Get(index);
}
inline void CmdHeader::set_exposure_color(int index, double value) {
  exposure_color_.Set(index, value);
}
inline void CmdHeader::add_exposure_color(double value) {
  exposure_color_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CmdHeader::exposure_color() const {
  return exposure_color_;
}
inline ::google::protobuf::RepeatedField< double >*
CmdHeader::mutable_exposure_color() {
  return &exposure_color_;
}

// repeated double gain = 12;
inline int CmdHeader::gain_size() const {
  return gain_.size();
}
inline void CmdHeader::clear_gain() {
  gain_.Clear();
}
inline double CmdHeader::gain(int index) const {
  return gain_.Get(index);
}
inline void CmdHeader::set_gain(int index, double value) {
  gain_.Set(index, value);
}
inline void CmdHeader::add_gain(double value) {
  gain_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CmdHeader::gain() const {
  return gain_;
}
inline ::google::protobuf::RepeatedField< double >*
CmdHeader::mutable_gain() {
  return &gain_;
}

// optional .vrm_protocol.CamCalib left_cam = 13;
inline bool CmdHeader::has_left_cam() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CmdHeader::set_has_left_cam() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CmdHeader::clear_has_left_cam() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CmdHeader::clear_left_cam() {
  if (left_cam_ != NULL) left_cam_->::vrm_protocol::CamCalib::Clear();
  clear_has_left_cam();
}
inline const ::vrm_protocol::CamCalib& CmdHeader::left_cam() const {
  return left_cam_ != NULL ? *left_cam_ : *default_instance_->left_cam_;
}
inline ::vrm_protocol::CamCalib* CmdHeader::mutable_left_cam() {
  set_has_left_cam();
  if (left_cam_ == NULL) left_cam_ = new ::vrm_protocol::CamCalib;
  return left_cam_;
}
inline ::vrm_protocol::CamCalib* CmdHeader::release_left_cam() {
  clear_has_left_cam();
  ::vrm_protocol::CamCalib* temp = left_cam_;
  left_cam_ = NULL;
  return temp;
}
inline void CmdHeader::set_allocated_left_cam(::vrm_protocol::CamCalib* left_cam) {
  delete left_cam_;
  left_cam_ = left_cam;
  if (left_cam) {
    set_has_left_cam();
  } else {
    clear_has_left_cam();
  }
}

// optional .vrm_protocol.CamCalib right_cam = 14;
inline bool CmdHeader::has_right_cam() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CmdHeader::set_has_right_cam() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CmdHeader::clear_has_right_cam() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CmdHeader::clear_right_cam() {
  if (right_cam_ != NULL) right_cam_->::vrm_protocol::CamCalib::Clear();
  clear_has_right_cam();
}
inline const ::vrm_protocol::CamCalib& CmdHeader::right_cam() const {
  return right_cam_ != NULL ? *right_cam_ : *default_instance_->right_cam_;
}
inline ::vrm_protocol::CamCalib* CmdHeader::mutable_right_cam() {
  set_has_right_cam();
  if (right_cam_ == NULL) right_cam_ = new ::vrm_protocol::CamCalib;
  return right_cam_;
}
inline ::vrm_protocol::CamCalib* CmdHeader::release_right_cam() {
  clear_has_right_cam();
  ::vrm_protocol::CamCalib* temp = right_cam_;
  right_cam_ = NULL;
  return temp;
}
inline void CmdHeader::set_allocated_right_cam(::vrm_protocol::CamCalib* right_cam) {
  delete right_cam_;
  right_cam_ = right_cam;
  if (right_cam) {
    set_has_right_cam();
  } else {
    clear_has_right_cam();
  }
}

// optional .vrm_protocol.CamCalib color_cam = 15;
inline bool CmdHeader::has_color_cam() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CmdHeader::set_has_color_cam() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CmdHeader::clear_has_color_cam() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CmdHeader::clear_color_cam() {
  if (color_cam_ != NULL) color_cam_->::vrm_protocol::CamCalib::Clear();
  clear_has_color_cam();
}
inline const ::vrm_protocol::CamCalib& CmdHeader::color_cam() const {
  return color_cam_ != NULL ? *color_cam_ : *default_instance_->color_cam_;
}
inline ::vrm_protocol::CamCalib* CmdHeader::mutable_color_cam() {
  set_has_color_cam();
  if (color_cam_ == NULL) color_cam_ = new ::vrm_protocol::CamCalib;
  return color_cam_;
}
inline ::vrm_protocol::CamCalib* CmdHeader::release_color_cam() {
  clear_has_color_cam();
  ::vrm_protocol::CamCalib* temp = color_cam_;
  color_cam_ = NULL;
  return temp;
}
inline void CmdHeader::set_allocated_color_cam(::vrm_protocol::CamCalib* color_cam) {
  delete color_cam_;
  color_cam_ = color_cam;
  if (color_cam) {
    set_has_color_cam();
  } else {
    clear_has_color_cam();
  }
}

// optional .vrm_protocol.ActiveCams active_cams = 16;
inline bool CmdHeader::has_active_cams() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CmdHeader::set_has_active_cams() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CmdHeader::clear_has_active_cams() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CmdHeader::clear_active_cams() {
  active_cams_ = 0;
  clear_has_active_cams();
}
inline ::vrm_protocol::ActiveCams CmdHeader::active_cams() const {
  return static_cast< ::vrm_protocol::ActiveCams >(active_cams_);
}
inline void CmdHeader::set_active_cams(::vrm_protocol::ActiveCams value) {
  assert(::vrm_protocol::ActiveCams_IsValid(value));
  set_has_active_cams();
  active_cams_ = value;
}

// optional bool simple_occlusion = 17;
inline bool CmdHeader::has_simple_occlusion() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CmdHeader::set_has_simple_occlusion() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CmdHeader::clear_has_simple_occlusion() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CmdHeader::clear_simple_occlusion() {
  simple_occlusion_ = false;
  clear_has_simple_occlusion();
}
inline bool CmdHeader::simple_occlusion() const {
  return simple_occlusion_;
}
inline void CmdHeader::set_simple_occlusion(bool value) {
  set_has_simple_occlusion();
  simple_occlusion_ = value;
}

// optional bool point_colors = 18;
inline bool CmdHeader::has_point_colors() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CmdHeader::set_has_point_colors() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CmdHeader::clear_has_point_colors() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CmdHeader::clear_point_colors() {
  point_colors_ = false;
  clear_has_point_colors();
}
inline bool CmdHeader::point_colors() const {
  return point_colors_;
}
inline void CmdHeader::set_point_colors(bool value) {
  set_has_point_colors();
  point_colors_ = value;
}

// -------------------------------------------------------------------

// ImgGroupHeader

// optional uint32 msg_id = 1;
inline bool ImgGroupHeader::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImgGroupHeader::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImgGroupHeader::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImgGroupHeader::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 ImgGroupHeader::msg_id() const {
  return msg_id_;
}
inline void ImgGroupHeader::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional double timestamp = 2;
inline bool ImgGroupHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImgGroupHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImgGroupHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImgGroupHeader::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ImgGroupHeader::timestamp() const {
  return timestamp_;
}
inline void ImgGroupHeader::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .vrm_protocol.CamMode cam_mode = 3;
inline bool ImgGroupHeader::has_cam_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImgGroupHeader::set_has_cam_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImgGroupHeader::clear_has_cam_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImgGroupHeader::clear_cam_mode() {
  cam_mode_ = 0;
  clear_has_cam_mode();
}
inline ::vrm_protocol::CamMode ImgGroupHeader::cam_mode() const {
  return static_cast< ::vrm_protocol::CamMode >(cam_mode_);
}
inline void ImgGroupHeader::set_cam_mode(::vrm_protocol::CamMode value) {
  assert(::vrm_protocol::CamMode_IsValid(value));
  set_has_cam_mode();
  cam_mode_ = value;
}

// optional uint32 sequence_id = 4;
inline bool ImgGroupHeader::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImgGroupHeader::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImgGroupHeader::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImgGroupHeader::clear_sequence_id() {
  sequence_id_ = 0u;
  clear_has_sequence_id();
}
inline ::google::protobuf::uint32 ImgGroupHeader::sequence_id() const {
  return sequence_id_;
}
inline void ImgGroupHeader::set_sequence_id(::google::protobuf::uint32 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// optional uint32 image_id = 5;
inline bool ImgGroupHeader::has_image_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImgGroupHeader::set_has_image_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImgGroupHeader::clear_has_image_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImgGroupHeader::clear_image_id() {
  image_id_ = 0u;
  clear_has_image_id();
}
inline ::google::protobuf::uint32 ImgGroupHeader::image_id() const {
  return image_id_;
}
inline void ImgGroupHeader::set_image_id(::google::protobuf::uint32 value) {
  set_has_image_id();
  image_id_ = value;
}

// optional uint32 num_images = 6;
inline bool ImgGroupHeader::has_num_images() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImgGroupHeader::set_has_num_images() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImgGroupHeader::clear_has_num_images() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImgGroupHeader::clear_num_images() {
  num_images_ = 0u;
  clear_has_num_images();
}
inline ::google::protobuf::uint32 ImgGroupHeader::num_images() const {
  return num_images_;
}
inline void ImgGroupHeader::set_num_images(::google::protobuf::uint32 value) {
  set_has_num_images();
  num_images_ = value;
}

// optional uint32 exposure_id = 7;
inline bool ImgGroupHeader::has_exposure_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImgGroupHeader::set_has_exposure_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImgGroupHeader::clear_has_exposure_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImgGroupHeader::clear_exposure_id() {
  exposure_id_ = 0u;
  clear_has_exposure_id();
}
inline ::google::protobuf::uint32 ImgGroupHeader::exposure_id() const {
  return exposure_id_;
}
inline void ImgGroupHeader::set_exposure_id(::google::protobuf::uint32 value) {
  set_has_exposure_id();
  exposure_id_ = value;
}

// optional uint32 num_exposures = 8;
inline bool ImgGroupHeader::has_num_exposures() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImgGroupHeader::set_has_num_exposures() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImgGroupHeader::clear_has_num_exposures() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImgGroupHeader::clear_num_exposures() {
  num_exposures_ = 0u;
  clear_has_num_exposures();
}
inline ::google::protobuf::uint32 ImgGroupHeader::num_exposures() const {
  return num_exposures_;
}
inline void ImgGroupHeader::set_num_exposures(::google::protobuf::uint32 value) {
  set_has_num_exposures();
  num_exposures_ = value;
}

// optional bool is_full_view = 9;
inline bool ImgGroupHeader::has_is_full_view() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImgGroupHeader::set_has_is_full_view() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImgGroupHeader::clear_has_is_full_view() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImgGroupHeader::clear_is_full_view() {
  is_full_view_ = false;
  clear_has_is_full_view();
}
inline bool ImgGroupHeader::is_full_view() const {
  return is_full_view_;
}
inline void ImgGroupHeader::set_is_full_view(bool value) {
  set_has_is_full_view();
  is_full_view_ = value;
}

// optional bool has_left_img = 10;
inline bool ImgGroupHeader::has_has_left_img() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImgGroupHeader::set_has_has_left_img() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImgGroupHeader::clear_has_has_left_img() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImgGroupHeader::clear_has_left_img() {
  has_left_img_ = false;
  clear_has_has_left_img();
}
inline bool ImgGroupHeader::has_left_img() const {
  return has_left_img_;
}
inline void ImgGroupHeader::set_has_left_img(bool value) {
  set_has_has_left_img();
  has_left_img_ = value;
}

// optional bool has_right_img = 11;
inline bool ImgGroupHeader::has_has_right_img() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImgGroupHeader::set_has_has_right_img() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImgGroupHeader::clear_has_has_right_img() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImgGroupHeader::clear_has_right_img() {
  has_right_img_ = false;
  clear_has_has_right_img();
}
inline bool ImgGroupHeader::has_right_img() const {
  return has_right_img_;
}
inline void ImgGroupHeader::set_has_right_img(bool value) {
  set_has_has_right_img();
  has_right_img_ = value;
}

// optional bool has_color_img = 12;
inline bool ImgGroupHeader::has_has_color_img() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImgGroupHeader::set_has_has_color_img() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImgGroupHeader::clear_has_has_color_img() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImgGroupHeader::clear_has_color_img() {
  has_color_img_ = false;
  clear_has_has_color_img();
}
inline bool ImgGroupHeader::has_color_img() const {
  return has_color_img_;
}
inline void ImgGroupHeader::set_has_color_img(bool value) {
  set_has_has_color_img();
  has_color_img_ = value;
}

// optional bool has_ambient_img = 13;
inline bool ImgGroupHeader::has_has_ambient_img() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ImgGroupHeader::set_has_has_ambient_img() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ImgGroupHeader::clear_has_has_ambient_img() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ImgGroupHeader::clear_has_ambient_img() {
  has_ambient_img_ = false;
  clear_has_has_ambient_img();
}
inline bool ImgGroupHeader::has_ambient_img() const {
  return has_ambient_img_;
}
inline void ImgGroupHeader::set_has_ambient_img(bool value) {
  set_has_has_ambient_img();
  has_ambient_img_ = value;
}

// optional bool has_point_color_img = 14;
inline bool ImgGroupHeader::has_has_point_color_img() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ImgGroupHeader::set_has_has_point_color_img() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ImgGroupHeader::clear_has_has_point_color_img() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ImgGroupHeader::clear_has_point_color_img() {
  has_point_color_img_ = false;
  clear_has_has_point_color_img();
}
inline bool ImgGroupHeader::has_point_color_img() const {
  return has_point_color_img_;
}
inline void ImgGroupHeader::set_has_point_color_img(bool value) {
  set_has_has_point_color_img();
  has_point_color_img_ = value;
}

// optional .vrm_protocol.PatternType pattern_type = 15;
inline bool ImgGroupHeader::has_pattern_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ImgGroupHeader::set_has_pattern_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ImgGroupHeader::clear_has_pattern_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ImgGroupHeader::clear_pattern_type() {
  pattern_type_ = 0;
  clear_has_pattern_type();
}
inline ::vrm_protocol::PatternType ImgGroupHeader::pattern_type() const {
  return static_cast< ::vrm_protocol::PatternType >(pattern_type_);
}
inline void ImgGroupHeader::set_pattern_type(::vrm_protocol::PatternType value) {
  assert(::vrm_protocol::PatternType_IsValid(value));
  set_has_pattern_type();
  pattern_type_ = value;
}

// -------------------------------------------------------------------

// CamCalib

// optional .vrm_protocol.VrmMatrix cam_mat = 1;
inline bool CamCalib::has_cam_mat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CamCalib::set_has_cam_mat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CamCalib::clear_has_cam_mat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CamCalib::clear_cam_mat() {
  if (cam_mat_ != NULL) cam_mat_->::vrm_protocol::VrmMatrix::Clear();
  clear_has_cam_mat();
}
inline const ::vrm_protocol::VrmMatrix& CamCalib::cam_mat() const {
  return cam_mat_ != NULL ? *cam_mat_ : *default_instance_->cam_mat_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::mutable_cam_mat() {
  set_has_cam_mat();
  if (cam_mat_ == NULL) cam_mat_ = new ::vrm_protocol::VrmMatrix;
  return cam_mat_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::release_cam_mat() {
  clear_has_cam_mat();
  ::vrm_protocol::VrmMatrix* temp = cam_mat_;
  cam_mat_ = NULL;
  return temp;
}
inline void CamCalib::set_allocated_cam_mat(::vrm_protocol::VrmMatrix* cam_mat) {
  delete cam_mat_;
  cam_mat_ = cam_mat;
  if (cam_mat) {
    set_has_cam_mat();
  } else {
    clear_has_cam_mat();
  }
}

// optional .vrm_protocol.VrmMatrix dist_coef = 2;
inline bool CamCalib::has_dist_coef() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CamCalib::set_has_dist_coef() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CamCalib::clear_has_dist_coef() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CamCalib::clear_dist_coef() {
  if (dist_coef_ != NULL) dist_coef_->::vrm_protocol::VrmMatrix::Clear();
  clear_has_dist_coef();
}
inline const ::vrm_protocol::VrmMatrix& CamCalib::dist_coef() const {
  return dist_coef_ != NULL ? *dist_coef_ : *default_instance_->dist_coef_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::mutable_dist_coef() {
  set_has_dist_coef();
  if (dist_coef_ == NULL) dist_coef_ = new ::vrm_protocol::VrmMatrix;
  return dist_coef_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::release_dist_coef() {
  clear_has_dist_coef();
  ::vrm_protocol::VrmMatrix* temp = dist_coef_;
  dist_coef_ = NULL;
  return temp;
}
inline void CamCalib::set_allocated_dist_coef(::vrm_protocol::VrmMatrix* dist_coef) {
  delete dist_coef_;
  dist_coef_ = dist_coef;
  if (dist_coef) {
    set_has_dist_coef();
  } else {
    clear_has_dist_coef();
  }
}

// optional .vrm_protocol.VrmMatrix rect_mat = 3;
inline bool CamCalib::has_rect_mat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CamCalib::set_has_rect_mat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CamCalib::clear_has_rect_mat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CamCalib::clear_rect_mat() {
  if (rect_mat_ != NULL) rect_mat_->::vrm_protocol::VrmMatrix::Clear();
  clear_has_rect_mat();
}
inline const ::vrm_protocol::VrmMatrix& CamCalib::rect_mat() const {
  return rect_mat_ != NULL ? *rect_mat_ : *default_instance_->rect_mat_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::mutable_rect_mat() {
  set_has_rect_mat();
  if (rect_mat_ == NULL) rect_mat_ = new ::vrm_protocol::VrmMatrix;
  return rect_mat_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::release_rect_mat() {
  clear_has_rect_mat();
  ::vrm_protocol::VrmMatrix* temp = rect_mat_;
  rect_mat_ = NULL;
  return temp;
}
inline void CamCalib::set_allocated_rect_mat(::vrm_protocol::VrmMatrix* rect_mat) {
  delete rect_mat_;
  rect_mat_ = rect_mat;
  if (rect_mat) {
    set_has_rect_mat();
  } else {
    clear_has_rect_mat();
  }
}

// optional .vrm_protocol.VrmMatrix proj_mat = 4;
inline bool CamCalib::has_proj_mat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CamCalib::set_has_proj_mat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CamCalib::clear_has_proj_mat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CamCalib::clear_proj_mat() {
  if (proj_mat_ != NULL) proj_mat_->::vrm_protocol::VrmMatrix::Clear();
  clear_has_proj_mat();
}
inline const ::vrm_protocol::VrmMatrix& CamCalib::proj_mat() const {
  return proj_mat_ != NULL ? *proj_mat_ : *default_instance_->proj_mat_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::mutable_proj_mat() {
  set_has_proj_mat();
  if (proj_mat_ == NULL) proj_mat_ = new ::vrm_protocol::VrmMatrix;
  return proj_mat_;
}
inline ::vrm_protocol::VrmMatrix* CamCalib::release_proj_mat() {
  clear_has_proj_mat();
  ::vrm_protocol::VrmMatrix* temp = proj_mat_;
  proj_mat_ = NULL;
  return temp;
}
inline void CamCalib::set_allocated_proj_mat(::vrm_protocol::VrmMatrix* proj_mat) {
  delete proj_mat_;
  proj_mat_ = proj_mat;
  if (proj_mat) {
    set_has_proj_mat();
  } else {
    clear_has_proj_mat();
  }
}

// -------------------------------------------------------------------

// VrmMatrix

// required uint32 rows = 1;
inline bool VrmMatrix::has_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VrmMatrix::set_has_rows() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VrmMatrix::clear_has_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VrmMatrix::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 VrmMatrix::rows() const {
  return rows_;
}
inline void VrmMatrix::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
}

// required uint32 cols = 2;
inline bool VrmMatrix::has_cols() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VrmMatrix::set_has_cols() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VrmMatrix::clear_has_cols() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VrmMatrix::clear_cols() {
  cols_ = 0u;
  clear_has_cols();
}
inline ::google::protobuf::uint32 VrmMatrix::cols() const {
  return cols_;
}
inline void VrmMatrix::set_cols(::google::protobuf::uint32 value) {
  set_has_cols();
  cols_ = value;
}

// repeated double data = 3 [packed = true];
inline int VrmMatrix::data_size() const {
  return data_.size();
}
inline void VrmMatrix::clear_data() {
  data_.Clear();
}
inline double VrmMatrix::data(int index) const {
  return data_.Get(index);
}
inline void VrmMatrix::set_data(int index, double value) {
  data_.Set(index, value);
}
inline void VrmMatrix::add_data(double value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
VrmMatrix::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
VrmMatrix::mutable_data() {
  return &data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vrm_protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vrm_protocol::VrmCmd>() {
  return ::vrm_protocol::VrmCmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vrm_protocol::CamMode>() {
  return ::vrm_protocol::CamMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vrm_protocol::TrigMode>() {
  return ::vrm_protocol::TrigMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vrm_protocol::ActiveCams>() {
  return ::vrm_protocol::ActiveCams_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vrm_protocol::PatternType>() {
  return ::vrm_protocol::PatternType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgHeaders_2eproto__INCLUDED
