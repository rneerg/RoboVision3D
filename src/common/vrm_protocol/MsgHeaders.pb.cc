// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgHeaders.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MsgHeaders.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace vrm_protocol {

namespace {

const ::google::protobuf::Descriptor* CmdHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CmdHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImgGroupHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImgGroupHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* CamCalib_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CamCalib_reflection_ = NULL;
const ::google::protobuf::Descriptor* VrmMatrix_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VrmMatrix_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* VrmCmd_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CamMode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrigMode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ActiveCams_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PatternType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_MsgHeaders_2eproto() {
  protobuf_AddDesc_MsgHeaders_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "MsgHeaders.proto");
  GOOGLE_CHECK(file != NULL);
  CmdHeader_descriptor_ = file->message_type(0);
  static const int CmdHeader_offsets_[18] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, msg_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, cam_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, trig_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, frame_rate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, pattern_partial_view_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, pattern_resolution_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, pattern_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, exposure_grey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, exposure_color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, gain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, left_cam_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, right_cam_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, color_cam_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, active_cams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, simple_occlusion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, point_colors_),
  };
  CmdHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CmdHeader_descriptor_,
      CmdHeader::default_instance_,
      CmdHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CmdHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CmdHeader));
  ImgGroupHeader_descriptor_ = file->message_type(1);
  static const int ImgGroupHeader_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, msg_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, cam_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, sequence_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, image_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, num_images_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, exposure_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, num_exposures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, is_full_view_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, has_left_img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, has_right_img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, has_color_img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, has_ambient_img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, has_point_color_img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, pattern_type_),
  };
  ImgGroupHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImgGroupHeader_descriptor_,
      ImgGroupHeader::default_instance_,
      ImgGroupHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImgGroupHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImgGroupHeader));
  CamCalib_descriptor_ = file->message_type(2);
  static const int CamCalib_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamCalib, cam_mat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamCalib, dist_coef_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamCalib, rect_mat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamCalib, proj_mat_),
  };
  CamCalib_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CamCalib_descriptor_,
      CamCalib::default_instance_,
      CamCalib_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamCalib, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamCalib, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CamCalib));
  VrmMatrix_descriptor_ = file->message_type(3);
  static const int VrmMatrix_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VrmMatrix, rows_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VrmMatrix, cols_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VrmMatrix, data_),
  };
  VrmMatrix_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VrmMatrix_descriptor_,
      VrmMatrix::default_instance_,
      VrmMatrix_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VrmMatrix, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VrmMatrix, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VrmMatrix));
  VrmCmd_descriptor_ = file->enum_type(0);
  CamMode_descriptor_ = file->enum_type(1);
  TrigMode_descriptor_ = file->enum_type(2);
  ActiveCams_descriptor_ = file->enum_type(3);
  PatternType_descriptor_ = file->enum_type(4);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_MsgHeaders_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CmdHeader_descriptor_, &CmdHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImgGroupHeader_descriptor_, &ImgGroupHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CamCalib_descriptor_, &CamCalib::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VrmMatrix_descriptor_, &VrmMatrix::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_MsgHeaders_2eproto() {
  delete CmdHeader::default_instance_;
  delete CmdHeader_reflection_;
  delete ImgGroupHeader::default_instance_;
  delete ImgGroupHeader_reflection_;
  delete CamCalib::default_instance_;
  delete CamCalib_reflection_;
  delete VrmMatrix::default_instance_;
  delete VrmMatrix_reflection_;
}

void protobuf_AddDesc_MsgHeaders_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020MsgHeaders.proto\022\014vrm_protocol\"\304\004\n\tCmd"
    "Header\022\016\n\006msg_id\030\001 \001(\r\022\021\n\ttimestamp\030\002 \001("
    "\001\022%\n\007command\030\003 \001(\0162\024.vrm_protocol.VrmCmd"
    "\022\'\n\010cam_mode\030\004 \001(\0162\025.vrm_protocol.CamMod"
    "e\022)\n\ttrig_mode\030\005 \001(\0162\026.vrm_protocol.Trig"
    "Mode\022\022\n\nframe_rate\030\006 \001(\001\022\034\n\024pattern_part"
    "ial_view\030\007 \001(\010\022\032\n\022pattern_resolution\030\010 \001"
    "(\r\022/\n\014pattern_type\030\t \001(\0162\031.vrm_protocol."
    "PatternType\022\025\n\rexposure_grey\030\n \003(\001\022\026\n\016ex"
    "posure_color\030\013 \003(\001\022\014\n\004gain\030\014 \003(\001\022(\n\010left"
    "_cam\030\r \001(\0132\026.vrm_protocol.CamCalib\022)\n\tri"
    "ght_cam\030\016 \001(\0132\026.vrm_protocol.CamCalib\022)\n"
    "\tcolor_cam\030\017 \001(\0132\026.vrm_protocol.CamCalib"
    "\022-\n\013active_cams\030\020 \001(\0162\030.vrm_protocol.Act"
    "iveCams\022\030\n\020simple_occlusion\030\021 \001(\010\022\024\n\014poi"
    "nt_colors\030\022 \001(\010\"\204\003\n\016ImgGroupHeader\022\016\n\006ms"
    "g_id\030\001 \001(\r\022\021\n\ttimestamp\030\002 \001(\001\022\'\n\010cam_mod"
    "e\030\003 \001(\0162\025.vrm_protocol.CamMode\022\023\n\013sequen"
    "ce_id\030\004 \001(\r\022\020\n\010image_id\030\005 \001(\r\022\022\n\nnum_ima"
    "ges\030\006 \001(\r\022\023\n\013exposure_id\030\007 \001(\r\022\025\n\rnum_ex"
    "posures\030\010 \001(\r\022\024\n\014is_full_view\030\t \001(\010\022\024\n\014h"
    "as_left_img\030\n \001(\010\022\025\n\rhas_right_img\030\013 \001(\010"
    "\022\025\n\rhas_color_img\030\014 \001(\010\022\027\n\017has_ambient_i"
    "mg\030\r \001(\010\022\033\n\023has_point_color_img\030\016 \001(\010\022/\n"
    "\014pattern_type\030\017 \001(\0162\031.vrm_protocol.Patte"
    "rnType\"\266\001\n\010CamCalib\022(\n\007cam_mat\030\001 \001(\0132\027.v"
    "rm_protocol.VrmMatrix\022*\n\tdist_coef\030\002 \001(\013"
    "2\027.vrm_protocol.VrmMatrix\022)\n\010rect_mat\030\003 "
    "\001(\0132\027.vrm_protocol.VrmMatrix\022)\n\010proj_mat"
    "\030\004 \001(\0132\027.vrm_protocol.VrmMatrix\"9\n\tVrmMa"
    "trix\022\014\n\004rows\030\001 \002(\r\022\014\n\004cols\030\002 \002(\r\022\020\n\004data"
    "\030\003 \003(\001B\002\020\001*p\n\006VrmCmd\022\017\n\013CMD_UNKNOWN\020\000\022\026\n"
    "\022CMD_SET_PARAMETERS\020\001\022\023\n\017CMD_TRIGGER_CAM"
    "\020\002\022\022\n\016CMD_SEND_CALIB\020\003\022\024\n\020CMD_UPDATE_CAL"
    "IB\020\004*s\n\007CamMode\022\020\n\014MODE_UNKNOWN\020\000\022\022\n\016MOD"
    "E_STREAMING\020\001\022\027\n\023MODE_STRIPE_PATTERN\020\002\022\033"
    "\n\027MODE_RANDOM_DOT_PATTERN\020\003\022\014\n\010MODE_HDR\020"
    "\004*U\n\010TrigMode\022\020\n\014TRIG_UNKNOWN\020\000\022\021\n\rTRIG_"
    "INTERNAL\020\001\022\021\n\rTRIG_EXTERNAL\020\002\022\021\n\rTRIG_SO"
    "FTWARE\020\003*y\n\nActiveCams\022\r\n\tCAMS_NONE\020\000\022\032\n"
    "\026CAMS_LEFT_CENTER_RIGHT\020\001\022\023\n\017CAMS_LEFT_R"
    "IGHT\020\002\022\024\n\020CAMS_LEFT_CENTER\020\003\022\025\n\021CAMS_CEN"
    "TER_RIGHT\020\004*<\n\013PatternType\022\023\n\017PATTERN_CO"
    "NV_GC\020\000\022\030\n\024PATTERN_LARGE_GAP_GC\020\001", 1753);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "MsgHeaders.proto", &protobuf_RegisterTypes);
  CmdHeader::default_instance_ = new CmdHeader();
  ImgGroupHeader::default_instance_ = new ImgGroupHeader();
  CamCalib::default_instance_ = new CamCalib();
  VrmMatrix::default_instance_ = new VrmMatrix();
  CmdHeader::default_instance_->InitAsDefaultInstance();
  ImgGroupHeader::default_instance_->InitAsDefaultInstance();
  CamCalib::default_instance_->InitAsDefaultInstance();
  VrmMatrix::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MsgHeaders_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MsgHeaders_2eproto {
  StaticDescriptorInitializer_MsgHeaders_2eproto() {
    protobuf_AddDesc_MsgHeaders_2eproto();
  }
} static_descriptor_initializer_MsgHeaders_2eproto_;
const ::google::protobuf::EnumDescriptor* VrmCmd_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VrmCmd_descriptor_;
}
bool VrmCmd_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CamMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CamMode_descriptor_;
}
bool CamMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TrigMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrigMode_descriptor_;
}
bool TrigMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ActiveCams_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ActiveCams_descriptor_;
}
bool ActiveCams_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PatternType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PatternType_descriptor_;
}
bool PatternType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int CmdHeader::kMsgIdFieldNumber;
const int CmdHeader::kTimestampFieldNumber;
const int CmdHeader::kCommandFieldNumber;
const int CmdHeader::kCamModeFieldNumber;
const int CmdHeader::kTrigModeFieldNumber;
const int CmdHeader::kFrameRateFieldNumber;
const int CmdHeader::kPatternPartialViewFieldNumber;
const int CmdHeader::kPatternResolutionFieldNumber;
const int CmdHeader::kPatternTypeFieldNumber;
const int CmdHeader::kExposureGreyFieldNumber;
const int CmdHeader::kExposureColorFieldNumber;
const int CmdHeader::kGainFieldNumber;
const int CmdHeader::kLeftCamFieldNumber;
const int CmdHeader::kRightCamFieldNumber;
const int CmdHeader::kColorCamFieldNumber;
const int CmdHeader::kActiveCamsFieldNumber;
const int CmdHeader::kSimpleOcclusionFieldNumber;
const int CmdHeader::kPointColorsFieldNumber;
#endif  // !_MSC_VER

CmdHeader::CmdHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CmdHeader::InitAsDefaultInstance() {
  left_cam_ = const_cast< ::vrm_protocol::CamCalib*>(&::vrm_protocol::CamCalib::default_instance());
  right_cam_ = const_cast< ::vrm_protocol::CamCalib*>(&::vrm_protocol::CamCalib::default_instance());
  color_cam_ = const_cast< ::vrm_protocol::CamCalib*>(&::vrm_protocol::CamCalib::default_instance());
}

CmdHeader::CmdHeader(const CmdHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CmdHeader::SharedCtor() {
  _cached_size_ = 0;
  msg_id_ = 0u;
  timestamp_ = 0;
  command_ = 0;
  cam_mode_ = 0;
  trig_mode_ = 0;
  frame_rate_ = 0;
  pattern_partial_view_ = false;
  pattern_resolution_ = 0u;
  pattern_type_ = 0;
  left_cam_ = NULL;
  right_cam_ = NULL;
  color_cam_ = NULL;
  active_cams_ = 0;
  simple_occlusion_ = false;
  point_colors_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CmdHeader::~CmdHeader() {
  SharedDtor();
}

void CmdHeader::SharedDtor() {
  if (this != default_instance_) {
    delete left_cam_;
    delete right_cam_;
    delete color_cam_;
  }
}

void CmdHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CmdHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CmdHeader_descriptor_;
}

const CmdHeader& CmdHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgHeaders_2eproto();
  return *default_instance_;
}

CmdHeader* CmdHeader::default_instance_ = NULL;

CmdHeader* CmdHeader::New() const {
  return new CmdHeader;
}

void CmdHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    msg_id_ = 0u;
    timestamp_ = 0;
    command_ = 0;
    cam_mode_ = 0;
    trig_mode_ = 0;
    frame_rate_ = 0;
    pattern_partial_view_ = false;
    pattern_resolution_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    pattern_type_ = 0;
    if (has_left_cam()) {
      if (left_cam_ != NULL) left_cam_->::vrm_protocol::CamCalib::Clear();
    }
    if (has_right_cam()) {
      if (right_cam_ != NULL) right_cam_->::vrm_protocol::CamCalib::Clear();
    }
    if (has_color_cam()) {
      if (color_cam_ != NULL) color_cam_->::vrm_protocol::CamCalib::Clear();
    }
    active_cams_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    simple_occlusion_ = false;
    point_colors_ = false;
  }
  exposure_grey_.Clear();
  exposure_color_.Clear();
  gain_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CmdHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 msg_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_timestamp;
        break;
      }

      // optional double timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_command;
        break;
      }

      // optional .vrm_protocol.VrmCmd command = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_command:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vrm_protocol::VrmCmd_IsValid(value)) {
            set_command(static_cast< ::vrm_protocol::VrmCmd >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_cam_mode;
        break;
      }

      // optional .vrm_protocol.CamMode cam_mode = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cam_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vrm_protocol::CamMode_IsValid(value)) {
            set_cam_mode(static_cast< ::vrm_protocol::CamMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_trig_mode;
        break;
      }

      // optional .vrm_protocol.TrigMode trig_mode = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trig_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vrm_protocol::TrigMode_IsValid(value)) {
            set_trig_mode(static_cast< ::vrm_protocol::TrigMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(49)) goto parse_frame_rate;
        break;
      }

      // optional double frame_rate = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_frame_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &frame_rate_)));
          set_has_frame_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_pattern_partial_view;
        break;
      }

      // optional bool pattern_partial_view = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pattern_partial_view:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pattern_partial_view_)));
          set_has_pattern_partial_view();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_pattern_resolution;
        break;
      }

      // optional uint32 pattern_resolution = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pattern_resolution:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pattern_resolution_)));
          set_has_pattern_resolution();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_pattern_type;
        break;
      }

      // optional .vrm_protocol.PatternType pattern_type = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pattern_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vrm_protocol::PatternType_IsValid(value)) {
            set_pattern_type(static_cast< ::vrm_protocol::PatternType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(81)) goto parse_exposure_grey;
        break;
      }

      // repeated double exposure_grey = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_exposure_grey:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 81, input, this->mutable_exposure_grey())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_exposure_grey())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(81)) goto parse_exposure_grey;
        if (input->ExpectTag(89)) goto parse_exposure_color;
        break;
      }

      // repeated double exposure_color = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_exposure_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 89, input, this->mutable_exposure_color())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_exposure_color())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(89)) goto parse_exposure_color;
        if (input->ExpectTag(97)) goto parse_gain;
        break;
      }

      // repeated double gain = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 97, input, this->mutable_gain())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_gain())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(97)) goto parse_gain;
        if (input->ExpectTag(106)) goto parse_left_cam;
        break;
      }

      // optional .vrm_protocol.CamCalib left_cam = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_left_cam:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_left_cam()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_right_cam;
        break;
      }

      // optional .vrm_protocol.CamCalib right_cam = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_right_cam:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_right_cam()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_color_cam;
        break;
      }

      // optional .vrm_protocol.CamCalib color_cam = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color_cam:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_color_cam()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_active_cams;
        break;
      }

      // optional .vrm_protocol.ActiveCams active_cams = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_active_cams:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vrm_protocol::ActiveCams_IsValid(value)) {
            set_active_cams(static_cast< ::vrm_protocol::ActiveCams >(value));
          } else {
            mutable_unknown_fields()->AddVarint(16, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_simple_occlusion;
        break;
      }

      // optional bool simple_occlusion = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_simple_occlusion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &simple_occlusion_)));
          set_has_simple_occlusion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_point_colors;
        break;
      }

      // optional bool point_colors = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_point_colors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &point_colors_)));
          set_has_point_colors();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CmdHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 msg_id = 1;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->msg_id(), output);
  }

  // optional double timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->timestamp(), output);
  }

  // optional .vrm_protocol.VrmCmd command = 3;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->command(), output);
  }

  // optional .vrm_protocol.CamMode cam_mode = 4;
  if (has_cam_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->cam_mode(), output);
  }

  // optional .vrm_protocol.TrigMode trig_mode = 5;
  if (has_trig_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trig_mode(), output);
  }

  // optional double frame_rate = 6;
  if (has_frame_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->frame_rate(), output);
  }

  // optional bool pattern_partial_view = 7;
  if (has_pattern_partial_view()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->pattern_partial_view(), output);
  }

  // optional uint32 pattern_resolution = 8;
  if (has_pattern_resolution()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->pattern_resolution(), output);
  }

  // optional .vrm_protocol.PatternType pattern_type = 9;
  if (has_pattern_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->pattern_type(), output);
  }

  // repeated double exposure_grey = 10;
  for (int i = 0; i < this->exposure_grey_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      10, this->exposure_grey(i), output);
  }

  // repeated double exposure_color = 11;
  for (int i = 0; i < this->exposure_color_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      11, this->exposure_color(i), output);
  }

  // repeated double gain = 12;
  for (int i = 0; i < this->gain_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      12, this->gain(i), output);
  }

  // optional .vrm_protocol.CamCalib left_cam = 13;
  if (has_left_cam()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->left_cam(), output);
  }

  // optional .vrm_protocol.CamCalib right_cam = 14;
  if (has_right_cam()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->right_cam(), output);
  }

  // optional .vrm_protocol.CamCalib color_cam = 15;
  if (has_color_cam()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->color_cam(), output);
  }

  // optional .vrm_protocol.ActiveCams active_cams = 16;
  if (has_active_cams()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      16, this->active_cams(), output);
  }

  // optional bool simple_occlusion = 17;
  if (has_simple_occlusion()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->simple_occlusion(), output);
  }

  // optional bool point_colors = 18;
  if (has_point_colors()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->point_colors(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CmdHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 msg_id = 1;
  if (has_msg_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->msg_id(), target);
  }

  // optional double timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->timestamp(), target);
  }

  // optional .vrm_protocol.VrmCmd command = 3;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->command(), target);
  }

  // optional .vrm_protocol.CamMode cam_mode = 4;
  if (has_cam_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->cam_mode(), target);
  }

  // optional .vrm_protocol.TrigMode trig_mode = 5;
  if (has_trig_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->trig_mode(), target);
  }

  // optional double frame_rate = 6;
  if (has_frame_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->frame_rate(), target);
  }

  // optional bool pattern_partial_view = 7;
  if (has_pattern_partial_view()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->pattern_partial_view(), target);
  }

  // optional uint32 pattern_resolution = 8;
  if (has_pattern_resolution()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->pattern_resolution(), target);
  }

  // optional .vrm_protocol.PatternType pattern_type = 9;
  if (has_pattern_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->pattern_type(), target);
  }

  // repeated double exposure_grey = 10;
  for (int i = 0; i < this->exposure_grey_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(10, this->exposure_grey(i), target);
  }

  // repeated double exposure_color = 11;
  for (int i = 0; i < this->exposure_color_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(11, this->exposure_color(i), target);
  }

  // repeated double gain = 12;
  for (int i = 0; i < this->gain_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(12, this->gain(i), target);
  }

  // optional .vrm_protocol.CamCalib left_cam = 13;
  if (has_left_cam()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->left_cam(), target);
  }

  // optional .vrm_protocol.CamCalib right_cam = 14;
  if (has_right_cam()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->right_cam(), target);
  }

  // optional .vrm_protocol.CamCalib color_cam = 15;
  if (has_color_cam()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->color_cam(), target);
  }

  // optional .vrm_protocol.ActiveCams active_cams = 16;
  if (has_active_cams()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      16, this->active_cams(), target);
  }

  // optional bool simple_occlusion = 17;
  if (has_simple_occlusion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->simple_occlusion(), target);
  }

  // optional bool point_colors = 18;
  if (has_point_colors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->point_colors(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CmdHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 msg_id = 1;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_id());
    }

    // optional double timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional .vrm_protocol.VrmCmd command = 3;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->command());
    }

    // optional .vrm_protocol.CamMode cam_mode = 4;
    if (has_cam_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cam_mode());
    }

    // optional .vrm_protocol.TrigMode trig_mode = 5;
    if (has_trig_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trig_mode());
    }

    // optional double frame_rate = 6;
    if (has_frame_rate()) {
      total_size += 1 + 8;
    }

    // optional bool pattern_partial_view = 7;
    if (has_pattern_partial_view()) {
      total_size += 1 + 1;
    }

    // optional uint32 pattern_resolution = 8;
    if (has_pattern_resolution()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pattern_resolution());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .vrm_protocol.PatternType pattern_type = 9;
    if (has_pattern_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pattern_type());
    }

    // optional .vrm_protocol.CamCalib left_cam = 13;
    if (has_left_cam()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->left_cam());
    }

    // optional .vrm_protocol.CamCalib right_cam = 14;
    if (has_right_cam()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->right_cam());
    }

    // optional .vrm_protocol.CamCalib color_cam = 15;
    if (has_color_cam()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->color_cam());
    }

    // optional .vrm_protocol.ActiveCams active_cams = 16;
    if (has_active_cams()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->active_cams());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bool simple_occlusion = 17;
    if (has_simple_occlusion()) {
      total_size += 2 + 1;
    }

    // optional bool point_colors = 18;
    if (has_point_colors()) {
      total_size += 2 + 1;
    }

  }
  // repeated double exposure_grey = 10;
  {
    int data_size = 0;
    data_size = 8 * this->exposure_grey_size();
    total_size += 1 * this->exposure_grey_size() + data_size;
  }

  // repeated double exposure_color = 11;
  {
    int data_size = 0;
    data_size = 8 * this->exposure_color_size();
    total_size += 1 * this->exposure_color_size() + data_size;
  }

  // repeated double gain = 12;
  {
    int data_size = 0;
    data_size = 8 * this->gain_size();
    total_size += 1 * this->gain_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CmdHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CmdHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CmdHeader::MergeFrom(const CmdHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  exposure_grey_.MergeFrom(from.exposure_grey_);
  exposure_color_.MergeFrom(from.exposure_color_);
  gain_.MergeFrom(from.gain_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_command()) {
      set_command(from.command());
    }
    if (from.has_cam_mode()) {
      set_cam_mode(from.cam_mode());
    }
    if (from.has_trig_mode()) {
      set_trig_mode(from.trig_mode());
    }
    if (from.has_frame_rate()) {
      set_frame_rate(from.frame_rate());
    }
    if (from.has_pattern_partial_view()) {
      set_pattern_partial_view(from.pattern_partial_view());
    }
    if (from.has_pattern_resolution()) {
      set_pattern_resolution(from.pattern_resolution());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_pattern_type()) {
      set_pattern_type(from.pattern_type());
    }
    if (from.has_left_cam()) {
      mutable_left_cam()->::vrm_protocol::CamCalib::MergeFrom(from.left_cam());
    }
    if (from.has_right_cam()) {
      mutable_right_cam()->::vrm_protocol::CamCalib::MergeFrom(from.right_cam());
    }
    if (from.has_color_cam()) {
      mutable_color_cam()->::vrm_protocol::CamCalib::MergeFrom(from.color_cam());
    }
    if (from.has_active_cams()) {
      set_active_cams(from.active_cams());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_simple_occlusion()) {
      set_simple_occlusion(from.simple_occlusion());
    }
    if (from.has_point_colors()) {
      set_point_colors(from.point_colors());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CmdHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CmdHeader::CopyFrom(const CmdHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdHeader::IsInitialized() const {

  if (has_left_cam()) {
    if (!this->left_cam().IsInitialized()) return false;
  }
  if (has_right_cam()) {
    if (!this->right_cam().IsInitialized()) return false;
  }
  if (has_color_cam()) {
    if (!this->color_cam().IsInitialized()) return false;
  }
  return true;
}

void CmdHeader::Swap(CmdHeader* other) {
  if (other != this) {
    std::swap(msg_id_, other->msg_id_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(command_, other->command_);
    std::swap(cam_mode_, other->cam_mode_);
    std::swap(trig_mode_, other->trig_mode_);
    std::swap(frame_rate_, other->frame_rate_);
    std::swap(pattern_partial_view_, other->pattern_partial_view_);
    std::swap(pattern_resolution_, other->pattern_resolution_);
    std::swap(pattern_type_, other->pattern_type_);
    exposure_grey_.Swap(&other->exposure_grey_);
    exposure_color_.Swap(&other->exposure_color_);
    gain_.Swap(&other->gain_);
    std::swap(left_cam_, other->left_cam_);
    std::swap(right_cam_, other->right_cam_);
    std::swap(color_cam_, other->color_cam_);
    std::swap(active_cams_, other->active_cams_);
    std::swap(simple_occlusion_, other->simple_occlusion_);
    std::swap(point_colors_, other->point_colors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CmdHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CmdHeader_descriptor_;
  metadata.reflection = CmdHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImgGroupHeader::kMsgIdFieldNumber;
const int ImgGroupHeader::kTimestampFieldNumber;
const int ImgGroupHeader::kCamModeFieldNumber;
const int ImgGroupHeader::kSequenceIdFieldNumber;
const int ImgGroupHeader::kImageIdFieldNumber;
const int ImgGroupHeader::kNumImagesFieldNumber;
const int ImgGroupHeader::kExposureIdFieldNumber;
const int ImgGroupHeader::kNumExposuresFieldNumber;
const int ImgGroupHeader::kIsFullViewFieldNumber;
const int ImgGroupHeader::kHasLeftImgFieldNumber;
const int ImgGroupHeader::kHasRightImgFieldNumber;
const int ImgGroupHeader::kHasColorImgFieldNumber;
const int ImgGroupHeader::kHasAmbientImgFieldNumber;
const int ImgGroupHeader::kHasPointColorImgFieldNumber;
const int ImgGroupHeader::kPatternTypeFieldNumber;
#endif  // !_MSC_VER

ImgGroupHeader::ImgGroupHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImgGroupHeader::InitAsDefaultInstance() {
}

ImgGroupHeader::ImgGroupHeader(const ImgGroupHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImgGroupHeader::SharedCtor() {
  _cached_size_ = 0;
  msg_id_ = 0u;
  timestamp_ = 0;
  cam_mode_ = 0;
  sequence_id_ = 0u;
  image_id_ = 0u;
  num_images_ = 0u;
  exposure_id_ = 0u;
  num_exposures_ = 0u;
  is_full_view_ = false;
  has_left_img_ = false;
  has_right_img_ = false;
  has_color_img_ = false;
  has_ambient_img_ = false;
  has_point_color_img_ = false;
  pattern_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImgGroupHeader::~ImgGroupHeader() {
  SharedDtor();
}

void ImgGroupHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ImgGroupHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImgGroupHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImgGroupHeader_descriptor_;
}

const ImgGroupHeader& ImgGroupHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgHeaders_2eproto();
  return *default_instance_;
}

ImgGroupHeader* ImgGroupHeader::default_instance_ = NULL;

ImgGroupHeader* ImgGroupHeader::New() const {
  return new ImgGroupHeader;
}

void ImgGroupHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    msg_id_ = 0u;
    timestamp_ = 0;
    cam_mode_ = 0;
    sequence_id_ = 0u;
    image_id_ = 0u;
    num_images_ = 0u;
    exposure_id_ = 0u;
    num_exposures_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    is_full_view_ = false;
    has_left_img_ = false;
    has_right_img_ = false;
    has_color_img_ = false;
    has_ambient_img_ = false;
    has_point_color_img_ = false;
    pattern_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImgGroupHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 msg_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_timestamp;
        break;
      }

      // optional double timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_cam_mode;
        break;
      }

      // optional .vrm_protocol.CamMode cam_mode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cam_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vrm_protocol::CamMode_IsValid(value)) {
            set_cam_mode(static_cast< ::vrm_protocol::CamMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sequence_id;
        break;
      }

      // optional uint32 sequence_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_id_)));
          set_has_sequence_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_image_id;
        break;
      }

      // optional uint32 image_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_image_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &image_id_)));
          set_has_image_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_num_images;
        break;
      }

      // optional uint32 num_images = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_images:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_images_)));
          set_has_num_images();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_exposure_id;
        break;
      }

      // optional uint32 exposure_id = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exposure_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exposure_id_)));
          set_has_exposure_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_num_exposures;
        break;
      }

      // optional uint32 num_exposures = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_exposures:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_exposures_)));
          set_has_num_exposures();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_is_full_view;
        break;
      }

      // optional bool is_full_view = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_full_view:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_full_view_)));
          set_has_is_full_view();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_has_left_img;
        break;
      }

      // optional bool has_left_img = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_left_img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_left_img_)));
          set_has_has_left_img();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_has_right_img;
        break;
      }

      // optional bool has_right_img = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_right_img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_right_img_)));
          set_has_has_right_img();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_has_color_img;
        break;
      }

      // optional bool has_color_img = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_color_img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_color_img_)));
          set_has_has_color_img();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_has_ambient_img;
        break;
      }

      // optional bool has_ambient_img = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_ambient_img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_ambient_img_)));
          set_has_has_ambient_img();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_has_point_color_img;
        break;
      }

      // optional bool has_point_color_img = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_point_color_img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_point_color_img_)));
          set_has_has_point_color_img();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_pattern_type;
        break;
      }

      // optional .vrm_protocol.PatternType pattern_type = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pattern_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vrm_protocol::PatternType_IsValid(value)) {
            set_pattern_type(static_cast< ::vrm_protocol::PatternType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(15, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImgGroupHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 msg_id = 1;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->msg_id(), output);
  }

  // optional double timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->timestamp(), output);
  }

  // optional .vrm_protocol.CamMode cam_mode = 3;
  if (has_cam_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->cam_mode(), output);
  }

  // optional uint32 sequence_id = 4;
  if (has_sequence_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->sequence_id(), output);
  }

  // optional uint32 image_id = 5;
  if (has_image_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->image_id(), output);
  }

  // optional uint32 num_images = 6;
  if (has_num_images()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->num_images(), output);
  }

  // optional uint32 exposure_id = 7;
  if (has_exposure_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->exposure_id(), output);
  }

  // optional uint32 num_exposures = 8;
  if (has_num_exposures()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->num_exposures(), output);
  }

  // optional bool is_full_view = 9;
  if (has_is_full_view()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->is_full_view(), output);
  }

  // optional bool has_left_img = 10;
  if (has_has_left_img()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->has_left_img(), output);
  }

  // optional bool has_right_img = 11;
  if (has_has_right_img()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->has_right_img(), output);
  }

  // optional bool has_color_img = 12;
  if (has_has_color_img()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->has_color_img(), output);
  }

  // optional bool has_ambient_img = 13;
  if (has_has_ambient_img()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->has_ambient_img(), output);
  }

  // optional bool has_point_color_img = 14;
  if (has_has_point_color_img()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->has_point_color_img(), output);
  }

  // optional .vrm_protocol.PatternType pattern_type = 15;
  if (has_pattern_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      15, this->pattern_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImgGroupHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 msg_id = 1;
  if (has_msg_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->msg_id(), target);
  }

  // optional double timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->timestamp(), target);
  }

  // optional .vrm_protocol.CamMode cam_mode = 3;
  if (has_cam_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->cam_mode(), target);
  }

  // optional uint32 sequence_id = 4;
  if (has_sequence_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->sequence_id(), target);
  }

  // optional uint32 image_id = 5;
  if (has_image_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->image_id(), target);
  }

  // optional uint32 num_images = 6;
  if (has_num_images()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->num_images(), target);
  }

  // optional uint32 exposure_id = 7;
  if (has_exposure_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->exposure_id(), target);
  }

  // optional uint32 num_exposures = 8;
  if (has_num_exposures()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->num_exposures(), target);
  }

  // optional bool is_full_view = 9;
  if (has_is_full_view()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->is_full_view(), target);
  }

  // optional bool has_left_img = 10;
  if (has_has_left_img()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->has_left_img(), target);
  }

  // optional bool has_right_img = 11;
  if (has_has_right_img()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->has_right_img(), target);
  }

  // optional bool has_color_img = 12;
  if (has_has_color_img()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->has_color_img(), target);
  }

  // optional bool has_ambient_img = 13;
  if (has_has_ambient_img()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->has_ambient_img(), target);
  }

  // optional bool has_point_color_img = 14;
  if (has_has_point_color_img()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->has_point_color_img(), target);
  }

  // optional .vrm_protocol.PatternType pattern_type = 15;
  if (has_pattern_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      15, this->pattern_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImgGroupHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 msg_id = 1;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_id());
    }

    // optional double timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional .vrm_protocol.CamMode cam_mode = 3;
    if (has_cam_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cam_mode());
    }

    // optional uint32 sequence_id = 4;
    if (has_sequence_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence_id());
    }

    // optional uint32 image_id = 5;
    if (has_image_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->image_id());
    }

    // optional uint32 num_images = 6;
    if (has_num_images()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_images());
    }

    // optional uint32 exposure_id = 7;
    if (has_exposure_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exposure_id());
    }

    // optional uint32 num_exposures = 8;
    if (has_num_exposures()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_exposures());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool is_full_view = 9;
    if (has_is_full_view()) {
      total_size += 1 + 1;
    }

    // optional bool has_left_img = 10;
    if (has_has_left_img()) {
      total_size += 1 + 1;
    }

    // optional bool has_right_img = 11;
    if (has_has_right_img()) {
      total_size += 1 + 1;
    }

    // optional bool has_color_img = 12;
    if (has_has_color_img()) {
      total_size += 1 + 1;
    }

    // optional bool has_ambient_img = 13;
    if (has_has_ambient_img()) {
      total_size += 1 + 1;
    }

    // optional bool has_point_color_img = 14;
    if (has_has_point_color_img()) {
      total_size += 1 + 1;
    }

    // optional .vrm_protocol.PatternType pattern_type = 15;
    if (has_pattern_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pattern_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImgGroupHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImgGroupHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImgGroupHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImgGroupHeader::MergeFrom(const ImgGroupHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_cam_mode()) {
      set_cam_mode(from.cam_mode());
    }
    if (from.has_sequence_id()) {
      set_sequence_id(from.sequence_id());
    }
    if (from.has_image_id()) {
      set_image_id(from.image_id());
    }
    if (from.has_num_images()) {
      set_num_images(from.num_images());
    }
    if (from.has_exposure_id()) {
      set_exposure_id(from.exposure_id());
    }
    if (from.has_num_exposures()) {
      set_num_exposures(from.num_exposures());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_is_full_view()) {
      set_is_full_view(from.is_full_view());
    }
    if (from.has_has_left_img()) {
      set_has_left_img(from.has_left_img());
    }
    if (from.has_has_right_img()) {
      set_has_right_img(from.has_right_img());
    }
    if (from.has_has_color_img()) {
      set_has_color_img(from.has_color_img());
    }
    if (from.has_has_ambient_img()) {
      set_has_ambient_img(from.has_ambient_img());
    }
    if (from.has_has_point_color_img()) {
      set_has_point_color_img(from.has_point_color_img());
    }
    if (from.has_pattern_type()) {
      set_pattern_type(from.pattern_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImgGroupHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImgGroupHeader::CopyFrom(const ImgGroupHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImgGroupHeader::IsInitialized() const {

  return true;
}

void ImgGroupHeader::Swap(ImgGroupHeader* other) {
  if (other != this) {
    std::swap(msg_id_, other->msg_id_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(cam_mode_, other->cam_mode_);
    std::swap(sequence_id_, other->sequence_id_);
    std::swap(image_id_, other->image_id_);
    std::swap(num_images_, other->num_images_);
    std::swap(exposure_id_, other->exposure_id_);
    std::swap(num_exposures_, other->num_exposures_);
    std::swap(is_full_view_, other->is_full_view_);
    std::swap(has_left_img_, other->has_left_img_);
    std::swap(has_right_img_, other->has_right_img_);
    std::swap(has_color_img_, other->has_color_img_);
    std::swap(has_ambient_img_, other->has_ambient_img_);
    std::swap(has_point_color_img_, other->has_point_color_img_);
    std::swap(pattern_type_, other->pattern_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImgGroupHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImgGroupHeader_descriptor_;
  metadata.reflection = ImgGroupHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CamCalib::kCamMatFieldNumber;
const int CamCalib::kDistCoefFieldNumber;
const int CamCalib::kRectMatFieldNumber;
const int CamCalib::kProjMatFieldNumber;
#endif  // !_MSC_VER

CamCalib::CamCalib()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CamCalib::InitAsDefaultInstance() {
  cam_mat_ = const_cast< ::vrm_protocol::VrmMatrix*>(&::vrm_protocol::VrmMatrix::default_instance());
  dist_coef_ = const_cast< ::vrm_protocol::VrmMatrix*>(&::vrm_protocol::VrmMatrix::default_instance());
  rect_mat_ = const_cast< ::vrm_protocol::VrmMatrix*>(&::vrm_protocol::VrmMatrix::default_instance());
  proj_mat_ = const_cast< ::vrm_protocol::VrmMatrix*>(&::vrm_protocol::VrmMatrix::default_instance());
}

CamCalib::CamCalib(const CamCalib& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CamCalib::SharedCtor() {
  _cached_size_ = 0;
  cam_mat_ = NULL;
  dist_coef_ = NULL;
  rect_mat_ = NULL;
  proj_mat_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CamCalib::~CamCalib() {
  SharedDtor();
}

void CamCalib::SharedDtor() {
  if (this != default_instance_) {
    delete cam_mat_;
    delete dist_coef_;
    delete rect_mat_;
    delete proj_mat_;
  }
}

void CamCalib::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CamCalib::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CamCalib_descriptor_;
}

const CamCalib& CamCalib::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgHeaders_2eproto();
  return *default_instance_;
}

CamCalib* CamCalib::default_instance_ = NULL;

CamCalib* CamCalib::New() const {
  return new CamCalib;
}

void CamCalib::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_cam_mat()) {
      if (cam_mat_ != NULL) cam_mat_->::vrm_protocol::VrmMatrix::Clear();
    }
    if (has_dist_coef()) {
      if (dist_coef_ != NULL) dist_coef_->::vrm_protocol::VrmMatrix::Clear();
    }
    if (has_rect_mat()) {
      if (rect_mat_ != NULL) rect_mat_->::vrm_protocol::VrmMatrix::Clear();
    }
    if (has_proj_mat()) {
      if (proj_mat_ != NULL) proj_mat_->::vrm_protocol::VrmMatrix::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CamCalib::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vrm_protocol.VrmMatrix cam_mat = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cam_mat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dist_coef;
        break;
      }

      // optional .vrm_protocol.VrmMatrix dist_coef = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dist_coef:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dist_coef()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_rect_mat;
        break;
      }

      // optional .vrm_protocol.VrmMatrix rect_mat = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rect_mat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rect_mat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_proj_mat;
        break;
      }

      // optional .vrm_protocol.VrmMatrix proj_mat = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proj_mat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_proj_mat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CamCalib::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vrm_protocol.VrmMatrix cam_mat = 1;
  if (has_cam_mat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cam_mat(), output);
  }

  // optional .vrm_protocol.VrmMatrix dist_coef = 2;
  if (has_dist_coef()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->dist_coef(), output);
  }

  // optional .vrm_protocol.VrmMatrix rect_mat = 3;
  if (has_rect_mat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->rect_mat(), output);
  }

  // optional .vrm_protocol.VrmMatrix proj_mat = 4;
  if (has_proj_mat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->proj_mat(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CamCalib::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .vrm_protocol.VrmMatrix cam_mat = 1;
  if (has_cam_mat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cam_mat(), target);
  }

  // optional .vrm_protocol.VrmMatrix dist_coef = 2;
  if (has_dist_coef()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->dist_coef(), target);
  }

  // optional .vrm_protocol.VrmMatrix rect_mat = 3;
  if (has_rect_mat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->rect_mat(), target);
  }

  // optional .vrm_protocol.VrmMatrix proj_mat = 4;
  if (has_proj_mat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->proj_mat(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CamCalib::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vrm_protocol.VrmMatrix cam_mat = 1;
    if (has_cam_mat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cam_mat());
    }

    // optional .vrm_protocol.VrmMatrix dist_coef = 2;
    if (has_dist_coef()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dist_coef());
    }

    // optional .vrm_protocol.VrmMatrix rect_mat = 3;
    if (has_rect_mat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rect_mat());
    }

    // optional .vrm_protocol.VrmMatrix proj_mat = 4;
    if (has_proj_mat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->proj_mat());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CamCalib::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CamCalib* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CamCalib*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CamCalib::MergeFrom(const CamCalib& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cam_mat()) {
      mutable_cam_mat()->::vrm_protocol::VrmMatrix::MergeFrom(from.cam_mat());
    }
    if (from.has_dist_coef()) {
      mutable_dist_coef()->::vrm_protocol::VrmMatrix::MergeFrom(from.dist_coef());
    }
    if (from.has_rect_mat()) {
      mutable_rect_mat()->::vrm_protocol::VrmMatrix::MergeFrom(from.rect_mat());
    }
    if (from.has_proj_mat()) {
      mutable_proj_mat()->::vrm_protocol::VrmMatrix::MergeFrom(from.proj_mat());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CamCalib::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CamCalib::CopyFrom(const CamCalib& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CamCalib::IsInitialized() const {

  if (has_cam_mat()) {
    if (!this->cam_mat().IsInitialized()) return false;
  }
  if (has_dist_coef()) {
    if (!this->dist_coef().IsInitialized()) return false;
  }
  if (has_rect_mat()) {
    if (!this->rect_mat().IsInitialized()) return false;
  }
  if (has_proj_mat()) {
    if (!this->proj_mat().IsInitialized()) return false;
  }
  return true;
}

void CamCalib::Swap(CamCalib* other) {
  if (other != this) {
    std::swap(cam_mat_, other->cam_mat_);
    std::swap(dist_coef_, other->dist_coef_);
    std::swap(rect_mat_, other->rect_mat_);
    std::swap(proj_mat_, other->proj_mat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CamCalib::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CamCalib_descriptor_;
  metadata.reflection = CamCalib_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VrmMatrix::kRowsFieldNumber;
const int VrmMatrix::kColsFieldNumber;
const int VrmMatrix::kDataFieldNumber;
#endif  // !_MSC_VER

VrmMatrix::VrmMatrix()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VrmMatrix::InitAsDefaultInstance() {
}

VrmMatrix::VrmMatrix(const VrmMatrix& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VrmMatrix::SharedCtor() {
  _cached_size_ = 0;
  rows_ = 0u;
  cols_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VrmMatrix::~VrmMatrix() {
  SharedDtor();
}

void VrmMatrix::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VrmMatrix::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VrmMatrix::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VrmMatrix_descriptor_;
}

const VrmMatrix& VrmMatrix::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgHeaders_2eproto();
  return *default_instance_;
}

VrmMatrix* VrmMatrix::default_instance_ = NULL;

VrmMatrix* VrmMatrix::New() const {
  return new VrmMatrix;
}

void VrmMatrix::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rows_ = 0u;
    cols_ = 0u;
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VrmMatrix::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 rows = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rows_)));
          set_has_rows();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_cols;
        break;
      }

      // required uint32 cols = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cols:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cols_)));
          set_has_cols();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // repeated double data = 3 [packed = true];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_data())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 26, input, this->mutable_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VrmMatrix::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 rows = 1;
  if (has_rows()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rows(), output);
  }

  // required uint32 cols = 2;
  if (has_cols()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cols(), output);
  }

  // repeated double data = 3 [packed = true];
  if (this->data_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_data_cached_byte_size_);
  }
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VrmMatrix::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 rows = 1;
  if (has_rows()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rows(), target);
  }

  // required uint32 cols = 2;
  if (has_cols()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cols(), target);
  }

  // repeated double data = 3 [packed = true];
  if (this->data_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _data_cached_byte_size_, target);
  }
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VrmMatrix::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 rows = 1;
    if (has_rows()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rows());
    }

    // required uint32 cols = 2;
    if (has_cols()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cols());
    }

  }
  // repeated double data = 3 [packed = true];
  {
    int data_size = 0;
    data_size = 8 * this->data_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _data_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VrmMatrix::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VrmMatrix* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VrmMatrix*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VrmMatrix::MergeFrom(const VrmMatrix& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rows()) {
      set_rows(from.rows());
    }
    if (from.has_cols()) {
      set_cols(from.cols());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VrmMatrix::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VrmMatrix::CopyFrom(const VrmMatrix& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrmMatrix::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void VrmMatrix::Swap(VrmMatrix* other) {
  if (other != this) {
    std::swap(rows_, other->rows_);
    std::swap(cols_, other->cols_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VrmMatrix::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VrmMatrix_descriptor_;
  metadata.reflection = VrmMatrix_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vrm_protocol

// @@protoc_insertion_point(global_scope)
